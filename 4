using UnityEngine;
using System.Collections;

public class NewBehaviourScript : MonoBehaviour {

	private int[] pk1 = new int[9];  //Массив хранит значения Ккал в час для 1 котла, однако помимо 8 табличных значений, есть значение равное 0, это позволяет сделать очень просым алгоритм подсчета (Понятно что в твоем случае этого даже хранить не надо, все уже есть в таблице).
	private float[] pk1Сost = new float[9];  //Массив хранит стоимость для 1 котла, соотвесвенно с массивом pk1 (тоесть pk1Cost[0] соотвесвует pk1[0] 30 - 18 198,34 р.  и т.д.)Понятно что в твоем случае этого даже хранить не надо, все уже есть в таблице.
	private int[] pk2 = new int[9]; // и т.д.
	private float[] pk2Сost = new float[9];
	private int[] pk3 = new int[9];
	private float[] pk3Сost = new float[9];
	private int[] pk4 = new int[10];
	private float[] pk4Сost = new float[10];
	private int[] pk5 = new int[10];
	private float[] pk5Сost = new float[10];
	private int[] pk6 = new int[10];
	private float[] pk6Сost = new float[10];



	public int _Q; //Значение Q указывается пользователем
	private int tempQ = 0; //Временное хранилище для подсчета суммы
	private float Price = 0.0f; //Сюда запишем наименьшую цену
	private int[] Cotly = new int[6]; //Сюда запишем какие котлы и на какую мощность включать



	private int _acc = 30; //Не обращай внимания, в моем случае используется просто для заполнения значениями

	void Start () {  //На фунцкии Start тоже не заморачивайся, опять же просто заполняю массивы значениями
		for (int i = 0; i < 10; i++) {
			if (i == 9) {
				pk1 [i-1] = 0;
				pk2 [i-1] = 0;
				pk3 [i-1] = 0;
				pk4 [i] = 0;
				pk5 [i] = 0;
				pk6 [i] = 0;
			} else {
				if (i != 8) {
					pk1 [i] = _acc;
					pk2 [i] = _acc;
					pk3 [i] = _acc;
				}
				pk4 [i] = _acc + 30;
				pk5 [i] = _acc + 30;
				pk6 [i] = _acc + 30;
				_acc += 10;
			}
		}

		pk1Сost[0] = 18198.34f;
		pk1Сost[1] = 24316.80f;
		pk1Сost[2] = 30468.05f;
		pk1Сost[3] = 36651.26f;
		pk1Сost[4] = 42864.42f;
		pk1Сost[5] = 49142.50f;
		pk1Сost[6] = 55465.46f;
		pk1Сost[7] = 61868.35f;
		pk1Сost[8] = 0.0f;

		pk2Сost[0] = 18519.46f;
		pk2Сost[1] = 24655.11f;
		pk2Сost[2] = 30850.56f;
		pk2Сost[3] = 37123.78f;
		pk2Сost[4] = 43397.59f;
		pk2Сost[5] = 49711.24f;
		pk2Сost[6] = 56065.02f;
		pk2Сost[7] = 62462.78f;
		pk2Сost[8] = 0.0f;

		pk3Сost[0] = 18372.65f;
		pk3Сost[1] = 24502.05f;
		pk3Сost[2] = 30728.37f;
		pk3Сost[3] = 36978.81f;
		pk3Сost[4] = 43222.06f;
		pk3Сost[5] = 49491.35f;
		pk3Сost[6] = 55812.52f;
		pk3Сost[7] = 62198.65f;
		pk3Сost[8] = 0.0f;

		pk4Сost[0] = 37750.59f;
		pk4Сost[1] = 44084.17f;
		pk4Сost[2] = 50416.86f;
		pk4Сost[3] = 56774.80f;
		pk4Сost[4] = 63198.37f;
		pk4Сost[5] = 69658.88f;
		pk4Сost[6] = 76167.31f;
		pk4Сost[7] = 82759.66f;
		pk4Сost[8] = 89441.50f;
		pk4Сost[9] = 0.0f;

		pk5Сost[0] = 36284.64f;
		pk5Сost[1] = 42304.11f;
		pk5Сost[2] = 48312.42f;
		pk5Сost[3] = 54317.35f;
		pk5Сost[4] = 60334.97f;
		pk5Сost[5] = 66355.66f;
		pk5Сost[6] = 72406.00f;
		pk5Сost[7] = 78619.11f;
		pk5Сost[8] = 84669.87f;
		pk5Сost[9] = 0.0f;

		pk6Сost[0] = 36202.27f;
		pk6Сost[1] = 42118.42f;
		pk6Сost[2] = 48079.61f;
		pk6Сost[3] = 54074.21f;
		pk6Сost[4] = 60176.32f;
		pk6Сost[5] = 66875.34f;
		pk6Сost[6] = 72866.85f;
		pk6Сost[7] = 78897.31f;
		pk6Сost[8] = 84944.49f;
		pk6Сost[9] = 0.0f;



		lookingAll (); // После заполнения массивов данными, уже начинаем непосредвенно считать
	}


	public void lookingAll(){
		float tempPrice = 0.0f; //Временная переменная для стоимости
		for (int i = 0; i < 9; i++) { //Начинаем цикл, проще говоря последовательно проверяем все возможные варианты
			for (int y = 0; y < 9; y++) {
				for (int t = 0; t < 9; t++) {
					for (int r = 0; r < 10; r++) {
						for (int e = 0; e < 10; e++) {
							for (int w = 0; w < 10; w++) {
								tempQ = pk1 [i] + pk2 [y] + pk3 [t] + pk4 [r] + pk5 [e] + pk6 [w]; //Непосредсвенно считаем сумму мощностей
								if (tempQ == _Q) { //Проверяем равна ли полученная сумма тому, что хотим получить
									tempPrice = pk1Сost [i] + pk2Сost [y] + pk3Сost [t] + pk4Сost [r] + pk5Сost [e] + pk6Сost [w]; //Если ровна, то берем данные из массива стоимости и считаем по чем данная комбинация нам обойдется
									if (Price == 0.0f) {//Если стоимость ровна 0, или говоря проще мы тут первый раз,
										Price = tempPrice;//то сразу говорим что временная стоимость ровна основной 
									}
									else if (tempPrice < Price) { //В противном случае (Если стоимость не 0) проверяем не меньше ли новая временная основной
										Price = tempPrice; // И если да, то записываем новую основную стоимость
										Cotly [0] = pk1 [i]; // Тут пнятно что шаговые значения в цикле хранят всю инфрмацию по нашим котлам, впринципе расорядится можно как угодно, я просто пишу в массив мощность
										Cotly [1] = pk2 [y]; // соотвесвенно 0 индекс первый котел 1 индекс второй и т.д. при это понятно то если мощность 0 то котел не используется
										Cotly [2] = pk3 [t];
										Cotly [3] = pk4 [r];
										Cotly [4] = pk5 [e];
										Cotly [5] = pk6 [w];
									} 
								}
							}
						}
					}
				}
			}
		}
		Debug.Log ("Котлы: " + Cotly[0] +" "+ Cotly[1] +" "+ Cotly[2] +" "+ Cotly[3] +" "+ Cotly[4] +" "+ Cotly[5]); //Здесь наш цикл окончен, и мы имеем массив с котлами, и окончательную минимальную стоимость соотвесвенно
		Debug.Log ("Итого: " + Price); // В данной программе они просто выводятся в консоль, а так сам понимаешь, что тебе с ними надо, то и делай )
	}

}
